//
// Created by sinigr on 09.11.2018.
//

#ifndef VANDERVURDTEMPLATES_MAXAUTO_H
#define VANDERVURDTEMPLATES_MAXAUTO_H

#include <type_traits>

namespace ch1 {

  // Вывод типов шаблона и auto
  // Вывод типа в шаблоне и auto полностью идентины, при этом
  // В шаблоне присутствует T и ParamType, а для auto
  // auto - T, спецификатор типа переменной - ParamType
  // Кроме одного случая, когда пишем auto x{22}; или auto x = {33};
  // В этом случае auto выводится как initializer_list<int>
  // В случае шаблона f ( { 11 , 23 1 9 } ) ; приведет к ошибки вывода типа

  // constexpr - не просто константа (в плане, что нельзя поменять) - оно известно на момент компиляции

  /*
   * - Объекты const expr являются константными и инициализируются объектам и, значения
   * которых известны во время компиляции.
   * - Функции const expr могут производить результаты времени ком пиляции при вызове
   * с аргументам и, значения которых известны во время компиляции.
   * - Объекты и функции constexpr могут использоваться в более широком диапазоне
   * контекстов по сравнению с объектам и и функциями, не являющимися constexpr.
   * constexpr является частью интерфейса объектов и функций.
   */

  /*
   * Таким образом, перемещающие операции генерируются (при необходимости)
   * для классов, только если выполняются три следующие условия:
   * • в классе не объявлены никакие копирующие операции;
   * • в классе не объявлены никакие перемещающие операции;
   * • в классе не объявлен деструктор.
   */

  /*
   * Если объявлен пользовательский деструктор, то должны быть либо объявлены
   * пользовательские операции присваивания и конструирования, либо явно указано, что нужно
   * создать их по умолчанию (= default), потому что в противном случае:
   * 1. Копирующие операции могут не соответствовать простому почленному копированию (которое генерирует компилятор)
   * 2. Операции перемещения не генерируются вовсе
   * Это является правилом большой тройки (деструктор, конструктор, присваивание)
   */

  /*
  • Специальные функции-члены - это те функции-члены, которые компиляторы могут
          генерировать самостоятельно: конструктор по умолчанию, деструктор, копирующие
          и перемещающие операции.
  • Перемещающие операции генерируются только для классов, в которых нет явно
          объявленных перемещающих операций, копирующих операций и деструктора.
  • Копирующий конструктор генерируется только для классов, в которых нет явно
          объявленного копирующего конструктора, и удаляется, если объявляется перемещающая
          операция. Копирующий оператор присваивания генерируется только
          для классов, в которых нет явно объявленного копирующего оператора присваивания,
          и удаляется, если объявляется перемещающая операция. Генерация копирующих
  операций в классах с явно объявленным деструктором является устаревшей
          и может быть отменена в будущем.
  • Шаблоны функций-членов не подавляют генерацию специальных функций-членов.
  */

  // 1.3.
  // 1.3.1. Параметр шаблона для возвращаемого типа

  // Можно указать только первый, остальные выведутся
  template<typename RT, typename T1, typename T2>
  RT max(T1 a, T2 b) {
      return a < b ? b : a;
  }

  // 1.3.2. Вывод возвращаемого типа (*Это лучший вариант)

  // С++14. Здесь auto выводится по правилам выведения параметров шаблона (Типы T и ParamType)
  template<typename T1, typename T2>
  auto max(T1 a, T2 b) {
      return a < b ? b : a;
  }

  // C++14. Вывод типа по правилам decltype (declared type).
  // Если возвращаемое выражение сложнее, чем выражение представляющее собой lvalue
  // То тип может вывестить как T&
  template<typename T1, typename T2>
  decltype(auto) max(T1 a, T2 b) {
      return a < b ? b : a;
  }

  // C++11 и C++14
  // Выводимый тип низводится при помощи std::decay, поэтому в этом случае он не может вывестись как T&
  template<typename T1, typename T2>
  auto max(T1 a, T2 b) -> std::decay_t<decltype(a<b?b:a)> {
      return a < b ? b : a;
  }

  // 1.3.3. Возвращаемый тип как общий тип

  // Вовзвращает "более общий" тип для типов переданных как параметры
  // std::common_type обеспечивает низведение типа, так что из фукции не может быть возвращена ссылка
  template<typename T1, typename T2>
  std::common_type_t<T1, T2> max(T1 a, T2 b) {
      return a < b ? b : a;
  }

  // 1.4

  /*
   * Можно также определить значения по умолчанию для параметров шаблона.
   * Эти значения называются аргументами шаблона по умолчанию и могут использоваться
   * с шаблонами любого вида. Они могут даже ссылаться на предыдущие
   * параметры шаблона.
   * */

    template<typename T1, typename T2, typename RT = std::common_type_t<T1, T2>>
    RT max(T1 a, T2 b) {
        return a < b ? b : a;
    }

}

#endif //VANDERVURDTEMPLATES_MAXAUTO_H
